section .data
    newLine db 13
    input db 256 dup(0) ; массив из 256 байт, все инициализированы нулями.

section .text
    global _start

_start:
    ; Считать ввод.
    mov eax, 0 ; Загрузка системного вызова для чтения в eax.
    mov edi, 0
    mov rsi, input ; Загрузка адреса буфера (в который будет сохранен ввод) в регистр rsi.
    mov edx, 256 ; Загрузка размера буфера в регистр edx.
    syscall ; Вызов системного вызова для чтения

    ; Вывести ввод.
    mov eax, 1 ; Загрузка системного вызова для записи в eax.
    mov edi, 1
    mov rsi, input ; Загрузка адреса буфера (из которого будет произведен вывод) в регистр rsi.
    syscall ; ; Вызов системного вызова для записи.

    call print_new_line

    ; Передача параметров в процедуру через стек.
    push rax               ; Передаём количество считанных символов.
    lea rax, [input]       ; Помещаем адрес ввода в rax.
    push rax               ; Помещаем адрес ввода на стек.
    call convert_to_uppercase
    add rsp, 16             ; Корректируем стек после вызова.

    ; Вывести ввод.
    mov eax, 1
    mov edi, 1
    mov rsi, input
    syscall

    ; Выход из программы.
    mov eax, 60
    xor edi, edi
    syscall

; Процедура для замены строчных букв в начале слов на прописные.
convert_to_uppercase:
    ; Сохраняем регистры.
    push rdi
    push rsi
    push rcx
    push rdx
    push rax
    push rbx

    mov rdi, [rsp + 56] ; Адрес строки.
    mov rcx, [rsp + 64] ; Длина строки.
    xor rax, rax        ; Обнуляем rax.
    cld                 ; Указываем, что строковые операции будут работать от начала строки к ее концу.

    ; Поиск первой буквы первого слова.
    .find_first_letter:
        mov al, ' '         ; Устанавливаем разделитель слов.
        repe scasb          ; Ищем первый символ.
        cmp rcx, 0          ; Проверка, достигнут ли конец строки.
        je .done            ; Если достигнут конец строки, завершаем.
        dec rdi             ; Уменьшаем rdi, чтобы он указывал на первую букву слова.
        mov bl, [rdi]       ; Сохраняем первую букву в bl.
        cmp bl, 'a'         ; Сравниваем с буквой 'a'.
        jl .find_next_word  ; Если буква в слове меньше 'a' (если она не является строчной буквой).
        cmp bl, 'z'         ; Сравниваем с буквой 'z'.
        jg .find_next_word  ; Если буква в слове больше 'z' (если она не является строчной буквой).
        and bl, 0xDF        ; Преобразуем строчную букву в прописную, сбрасывая 6-й бит (делает букву заглавной).
        mov [rdi], bl       ; Сохраняем измененный символ обратно в память.
        jmp .find_next_word ; Идем к следующему слову.

    ; Поиск следующего слова.
    .find_next_word:
        mov al, ' '         ; Устанавливаем разделитель слов.
        repne scasb         ; Ищем следующий пробел.
        repe scasb          ; Ищем начало слова.
        cmp rcx, 0          ; Проверка, достигнут ли конец строки.
        je .done            ; Если достигнут конец строки, завершаем.
        dec rdi             ; Уменьшаем rdi, чтобы он указывал на первую букву слова.
        mov al, [rdi]       ; Сохраняем первую букву в al.
        cmp al, 'a'         ; Сравниваем с буквой 'a'.
        jl .find_next_word  ; Если буква в слове меньше 'a' (если она не является строчной буквой).
        cmp al, 'z'         ; Сравниваем с буквой 'z'.
        jg .find_next_word  ; Если буква в слове больше 'z' (если она не является строчной буквой).
        and al, 0xDF        ; Преобразуем строчную букву в прописную, сбрасывая 6-й бит (делает букву заглавной).
        mov [rdi], al       ; Сохраняем измененный символ обратно в память.
        jmp .find_next_word ; Идем к следующему слову.

    .done:
        ; Восстанавливаем регистры.
        pop rbx
        pop rax
        pop rdx
        pop rcx
        pop rsi
        pop rdi

        
        ret

print_new_line:
    push rax
    push rdi
    push rsi
    push rdx
    
    ; Параметры для системного вызова write.
    mov rax, 1
    mov rdi, 1
    mov rsi, newLine
    mov rdx, 1
    syscall

    ; Восстанавливаем состояние регистров.
    pop rdx
    pop rsi
    pop rdi
    pop rax
    
    ret
